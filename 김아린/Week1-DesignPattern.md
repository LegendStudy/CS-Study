# 싱글톤 패턴

> 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
>

### MongoDB

### MySQL

<aside>
👉 **장점** 인스턴스를 생성할 때 드는 비용이 줄어든다

</aside>

<aside>
👉 **단점** 의존성이 높아진다
TDD 개발을 할 때 걸림돌이 될 수 있음.
단위 테스트를 할 때 테스트가 서로 독립적이어야 하며, 어떤 순서든 실행할 수 있어야 하는데
싱글톤 패턴은 미리 생성된 하나의 인스턴스를 구현하는 패턴이므로 각 테스트가 독립적이기 어려움.
→ 의존성 주입을 통해 모듈 간 결합을 느슨하게 할 수 있다

</aside>

## 의존성 주입

상위 모듈은 하위 모듈에서 어떠한 것도 가져오면 안된다

둘 다 추상화에 의존해야 하며, 추상화는 세부사항에 의존하지 말아야 한다

# 팩토리 패턴

> 객체를 사용하는 코드에서 객체 생성 부분을 떼어나 추상화한 패턴
상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를, 하위 클래스에서 구체적인 내용을 결정하는 패턴
>

<aside>
👉 상위, 하위 클래스가 분리되므로 느슨한 결합을 가짐.
상위 클래스는 인스턴스 생성 방식을 알 필요가 없으므로 더 많은 유연성을 가짐.
객체 생성 로직이 분리되어 있으므로 유지보수가 쉬워짐

</aside>

# 전략 패턴

> 객체 행위를 직접 수정하지 않고 ‘캡슐화한 알고리즘’을 바꿔주는 패턴
>

<aside>
👉 **상속(extends)** 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하는 것

</aside>

<aside>
👉 **구현(implements)**은 부모 인터페이스(interface)를 자식 클래스에서 재정의하여 구현하는 것

</aside>

<aside>
👉 상속은 일반 클래스, 추상 클래스 기반
구현은 인터페이스 기반

</aside>

## 프록시(proxy)

> 어떠한 대상의 기본적인 동작을 가로챌 수 있는 객체
>

target : 프록시할 대상

handler : target 동작을 가로채고 어떤 동작을 할 것인지 설정되어 있는 함수

# 프록시 패턴

> 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 역할 계층이 있는 디자인 패턴
>

# 프록시 서버

> 서버와 클라이언트 사이에서 클라이언트가 간접적으로 다른 서비스에 접속할 수 있게 해주는 서버
>

# 이터레이터 패턴

> 이터레이터를 사용하여 컬렉션 요소들에 접근하는 디자인 패턴
>

# 노출모듈 패턴

> 즉시 실행 함수를 통해 접근 제어자(private)를 만드는 패턴
>

# MVC 패턴

> 모델, 뷰, 컨트롤러
>

# MVP 패턴

> 모델, 뷰, 프레젠터
>

# MVVM 패턴

> 뷰, 뷰모델, 모델
>